# 邏輯統一實體架構解決方案

## 問題背景

在傳送門系統中，當幽靈實體碰撞到牆壁時應該停止，此時尚未傳送過來的主體也必須停止，因為它們邏輯上是同一個物體。原有的主體↔幽靈雙向同步機制無法有效處理這種情況，需要一個統一的邏輯實體來控制兩者。

## 核心解決方案

### 1. 邏輯實體層 (Logical Entity Layer)

引入 `LogicalEntity` 作為主體和幽靈的統一控制層：
- **邏輯實體**: 抽象的統一控制單位，不是物理世界中的實體
- **物理狀態合成**: 將主體和幽靈的物理狀態合成為邏輯實體的統一狀態
- **單向同步**: 邏輯實體 → 主體/幽靈，避免循環依賴和衝突
- **約束傳播**: 任一物理實體被約束時，約束會傳播到整個邏輯實體

### 2. 責任分工

#### 傳送門庫 (Portal Library)
- ✅ 邏輯實體生命周期管理
- ✅ 物理狀態合成算法實現
- ✅ 約束檢測和應用邏輯
- ✅ 統一狀態同步到物理實體
- ✅ 事件驅動的狀態管理

#### 物理引擎 (Physics Engine)
- ✅ 提供碰撞檢測和約束信息
- ✅ 提供實體物理狀態查詢接口
- ✅ 接收並應用來自邏輯實體的強制狀態設置
- ✅ 支持禁用特定實體的引擎控制
- ✅ 提供批量狀態更新接口

#### 遊戲引擎 (Game Engine)
- ✅ 實現物理接口 (IPhysicsDataProvider, IPhysicsManipulator)
- ✅ 轉發物理事件到傳送門庫
- ✅ 管理實體的物理引擎控制開關
- ✅ 提供相交檢測事件

### 3. 核心工作流程

```
每幀更新流程:
┌─────────────────┐
│ 1. 收集物理狀態  │ ← 從物理引擎查詢主體和幽靈狀態
├─────────────────┤
│ 2. 狀態合成     │ ← 根據策略合成統一的邏輯狀態  
├─────────────────┤
│ 3. 約束檢測     │ ← 檢查任一實體是否被阻擋
├─────────────────┤
│ 4. 約束應用     │ ← 修正邏輯狀態以符合約束
├─────────────────┤
│ 5. 狀態同步     │ ← 強制設置主體和幽靈的狀態
└─────────────────┘
```

### 4. 狀態合成策略

- **MOST_RESTRICTIVE**: 使用最受約束的狀態（推薦用於碰撞處理）
- **MAIN_PRIORITY**: 主體實體優先
- **GHOST_PRIORITY**: 幽靈實體優先  
- **WEIGHTED_AVERAGE**: 加權平均合成
- **CUSTOM_LOGIC**: 自定義合成邏輯

### 5. 約束處理機制

當檢測到約束時：
1. **約束檢測**: 查詢物理引擎獲取碰撞信息
2. **約束合成**: 根據策略選擇最嚴格的約束
3. **速度修正**: 移除朝向阻擋面的速度分量
4. **狀態同步**: 將修正後的狀態應用到所有相關實體

### 6. 事件驅動架構

```cpp
// 邏輯實體相關事件
on_logical_entity_created()         // 邏輯實體創建
on_logical_entity_constrained()     // 被約束（碰牆等）
on_logical_entity_constraint_released() // 約束解除
on_logical_entity_state_merged()    // 狀態合成完成
```

## 技術實現要點

### 1. 接口擴展

```cpp
// 新增物理引擎接口
set_entity_physics_engine_controlled() // 控制物理引擎是否控制實體
detect_entity_collision_constraints()  // 檢測碰撞約束
force_set_entity_physics_state()       // 強制設置物理狀態
force_set_entities_physics_states()    // 批量強制設置
```

### 2. 核心類別

- `LogicalEntityManager`: 邏輯實體管理器
- `LogicalEntityState`: 邏輯實體狀態
- `PhysicsConstraintState`: 物理約束狀態
- `PhysicsStateMergeStrategy`: 狀態合成策略

### 3. 性能優化

- **批量狀態更新**: 減少物理引擎調用次數
- **可配置更新頻率**: 根據需求調整更新頻率
- **智能約束檢測**: 只在必要時進行約束檢測
- **事件驅動更新**: 避免不必要的狀態檢查

## 通用物理引擎支持

這個架構設計為通用解決方案，支持不同的物理引擎：

### 所有物理引擎都需要支持：
✅ 實體狀態查詢 (位置、速度、旋轉等)
✅ 實體狀態設置 (強制設置位置、速度等)  
✅ 碰撞檢測事件 (實體相交、分離等)
✅ 控制開關 (啟用/禁用引擎對特定實體的控制)

### 高級功能 (可選)：
🔄 批量狀態操作
🔄 自定義約束檢測
🔄 細粒度碰撞信息

## 使用示例

```cpp
// 啟用邏輯實體控制模式
teleport_manager->set_logical_entity_control_mode(true);

// 設置合成策略為最嚴格約束
teleport_manager->set_logical_entity_merge_strategy(
    entity_id, PhysicsStateMergeStrategy::MOST_RESTRICTIVE);

// 檢查是否被約束
if (teleport_manager->is_logical_entity_constrained(entity_id)) {
    auto constraint = teleport_manager->get_logical_entity_constraint(entity_id);
    // 處理約束情況...
}
```

## 總結

這個邏輯統一實體架構完美解決了主體和幽靈實體的同步問題：

1. **統一控制**: 邏輯實體作為統一控制層，確保主體和幽靈表現一致
2. **約束傳播**: 任一實體被阻擋時，整個邏輯實體都受約束
3. **事件驅動**: 完全基於事件，不包含物理模擬邏輯
4. **引擎無關**: 通用設計，支持各種物理引擎
5. **性能優化**: 批量操作和智能更新機制

當幽靈碰牆時，約束會通過邏輯實體傳播到主體，實現真正的統一物理行為。
