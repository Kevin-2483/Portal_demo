# 多段裁切系统可视化图解

## 1. 传统单传送门裁切 vs 多传送门链式裁切

### 单传送门裁切（传统方法）
```text
玩家模型穿越单个传送门：

    [玩家身体部分A]  |  传送门平面  |  [玩家身体部分B]
         原位置      |     裁切面     |      目标位置
         
只需要1个裁切平面，将玩家分成2段：
- 段1：显示在原传送门前
- 段2：显示在目标传送门后
```

### 多传送门链式裁切（新方法）
```text
玩家模型连续穿越3个传送门：

位置1: [段1] - 传送门P1|P2 - [段2] - 传送门P3|P4 - [段3] - 传送门P5|P6 - [段4] :位置4

需要3个裁切平面，将玩家分成4段：
- 段1：显示在位置1
- 段2：显示在位置2  
- 段3：显示在位置3
- 段4：显示在位置4
```

## 2. 算法执行流程可视化

### 步骤1：链初始化
```text
玩家进入第一个传送门P1：

实体链状态：
┌─────────────┐
│  原始玩家   │ <-- 主体位置 (main_position = 0)
│  @位置1     │
│  EntityType:│
│  MAIN       │
└─────────────┘

裁切状态：无需裁切（只有1个节点）
```

### 步骤2：链扩展（创建第一个幽灵）
```text
玩家质心与传送门P1相交：

实体链状态：
┌─────────────┐    ┌─────────────┐
│  原始玩家   │    │   幽灵1     │
│  @位置1     │----│  @位置2     │
│  EntityType:│    │  EntityType:│
│  MAIN       │    │  GHOST      │
└─────────────┘    └─────────────┘
     ^主体                ^新节点

裁切状态：
- 计算位置1和位置2之间的中点
- 生成垂直裁切平面
- 玩家被分成2段显示
```

### 步骤3：主体位置迁移
```text
玩家质心完全穿过传送门P1：

角色交换前：
┌─────────────┐    ┌─────────────┐
│  原始玩家   │    │   幽灵1     │
│  @位置1     │----│  @位置2     │
│EntityType:  │    │EntityType:  │
│MAIN (旧主体)│    │GHOST        │
└─────────────┘    └─────────────┘

角色交换后：
┌─────────────┐    ┌─────────────┐
│   幽灵      │    │   玩家      │
│  @位置1     │----│  @位置2     │
│EntityType:  │    │EntityType:  │
│GHOST        │    │MAIN (新主体)│
└─────────────┘    └─────────────┘
                        ^主体位置迁移到这里

裁切状态：保持不变，仍然是2段显示
```

### 步骤4：链进一步扩展
```text
玩家（现在在位置2）进入传送门P3：

实体链状态：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   幽灵      │    │   玩家      │    │   幽灵2     │
│  @位置1     │----│  @位置2     │----│  @位置3     │
│EntityType:  │    │EntityType:  │    │EntityType:  │
│GHOST        │    │MAIN         │    │GHOST        │
└─────────────┘    └─────────────┘    └─────────────┘
                        ^主体              ^新节点

裁切状态：
- 计算2个裁切平面：
  * 平面1：位置1和位置2之间
  * 平面2：位置2和位置3之间
- 玩家被分成3段显示
```

### 步骤5：链收缩
```text
幽灵（在位置1）完全退出传送门P1：

收缩前：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   幽灵      │    │   玩家      │    │   幽灵2     │
│  @位置1     │----│  @位置2     │----│  @位置3     │
│EntityType:  │    │EntityType:  │    │EntityType:  │
│GHOST        │    │MAIN         │    │GHOST        │
└─────────────┘    └─────────────┘    └─────────────┘

收缩后（移除第一个节点）：
                   ┌─────────────┐    ┌─────────────┐
                   │   玩家      │    │   幽灵2     │
                   │  @位置2     │----│  @位置3     │
                   │EntityType:  │    │EntityType:  │
                   │MAIN         │    │GHOST        │
                   └─────────────┘    └─────────────┘
                        ^主体位置调整

裁切状态：
- 只需要1个裁切平面：位置2和位置3之间
- 玩家回到2段显示
```

## 3. 裁切平面计算详解

### 3.1 相邻节点间裁切平面计算
```text
给定两个相邻节点：
节点A: 位置(x1, y1, z1)
节点B: 位置(x2, y2, z2)

计算步骤：
1. 中点计算：
   midpoint = ((x1+x2)/2, (y1+y2)/2, (z1+z2)/2)

2. 方向向量：
   direction = normalize((x2-x1, y2-y1, z2-z1))

3. 裁切平面：
   plane.normal = direction
   plane.distance = dot(midpoint, direction)

示例：
节点A: (0, 0, 0)
节点B: (10, 0, 0)
中点: (5, 0, 0)
方向: (1, 0, 0)
平面: normal=(1,0,0), distance=5

该平面将在x=5处分割物体
```

### 3.2 多段裁切描述符生成
```text
对于有4个节点的链：
[节点0] - [节点1] - [节点2] - [节点3]

生成3个裁切平面：
平面0：节点0和节点1之间
平面1：节点1和节点2之间  
平面2：节点2和节点3之间

每个节点的裁切设置：
节点0: 后裁切平面0 (只裁掉后面)
节点1: 前裁切平面0 + 后裁切平面1 (前后都裁)
节点2: 前裁切平面1 + 后裁切平面2 (前后都裁)
节点3: 前裁切平面2 (只裁掉前面)

渲染结果：
节点0: 显示物体的前半部分
节点1: 显示物体的中间部分1
节点2: 显示物体的中间部分2  
节点3: 显示物体的后半部分
```

## 4. GPU渲染管线集成

### 4.1 模板缓冲区技术
```text
For 节点i with N个裁切平面:

Step 1: 清除模板缓冲区
glClear(GL_STENCIL_BUFFER_BIT)

Step 2: 为每个裁切平面写入模板值
for j in range(N):
    glStencilFunc(GL_ALWAYS, stencil_value_j, 0xFF)
    glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE)
    render_clipping_plane_to_stencil(planes[j])

Step 3: 使用模板测试渲染物体
glStencilFunc(GL_EQUAL, final_stencil_value, 0xFF)
render_entity_geometry(entity_id)

结果: 只有通过所有裁切测试的像素才会被渲染
```

### 4.2 着色器裁切代码
```glsl
// 顶点着色器
#version 330 core

layout(location = 0) in vec3 position;
uniform mat4 model_matrix;
uniform mat4 view_matrix;
uniform mat4 projection_matrix;

// 支持多个裁切平面
uniform int num_clipping_planes;
uniform vec4 clipping_planes[8]; // 最多8个裁切平面

out vec3 world_position;
out float gl_ClipDistance[8];

void main() {
    vec4 world_pos = model_matrix * vec4(position, 1.0);
    world_position = world_pos.xyz;
    
    // 计算到每个裁切平面的距离
    for (int i = 0; i < num_clipping_planes; ++i) {
        gl_ClipDistance[i] = dot(world_pos, clipping_planes[i]);
    }
    
    gl_Position = projection_matrix * view_matrix * world_pos;
}
```

## 5. 性能优化可视化

### 5.1 LOD系统工作原理
```text
相机距离对可见段数的影响：

距离 < 10单位：显示所有4段
┌───┐ ┌───┐ ┌───┐ ┌───┐
│ 1 │ │ 2 │ │ 3 │ │ 4 │
└───┘ └───┘ └───┘ └───┘

距离 10-20单位：显示前3段
┌───┐ ┌───┐ ┌───┐
│ 1 │ │ 2 │ │ 3 │
└───┘ └───┘ └───┘

距离 20-30单位：显示前2段  
┌───┐ ┌───┐
│ 1 │ │ 2 │
└───┘ └───┘

距离 > 30单位：只显示主段
┌───┐
│ M │  (M = 主体段)
└───┘
```

### 5.2 批量渲染优化
```text
传统方式（低效）：
for each segment:
    setup_render_state(segment)
    render(segment)
    // 频繁的GPU状态切换

优化方式（高效）：
group_by_render_state(all_segments)
for each render_state_group:
    setup_render_state(group)
    for each segment in group:
        quick_render(segment)  // 只更新model matrix
    // 最少的GPU状态切换
```

## 6. 实际渲染效果示例

### 场景：玩家穿越双传送门的视觉效果
```text
传送门布局：
┌─────┐                    ┌─────┐
│ P1  │ ←→ (传送连接) ←→ │ P2  │
└─────┘                    └─────┘
  ^                          ^
 房间A                     房间B

┌─────┐                    ┌─────┐  
│ P3  │ ←→ (传送连接) ←→ │ P4  │
└─────┘                    └─────┘
  ^                          ^
 房间C                     房间D

玩家移动路径：房间A → P1 → 房间B → P3 → 房间C

视觉效果时间线：

t=0: 玩家完全在房间A
[玩家████████]

t=1: 玩家开始进入P1
[玩家████] | P1 | [幽灵████] (房间B)
    ^房间A      裁切面      ^房间B

t=2: 玩家质心穿过P1，到达房间B，开始进入P3
[幽灵████] (房间A) | [玩家████] | P3 | [幽灵████] (房间C)
   ^房间A                ^房间B      裁切面     ^房间C

t=3: 玩家质心穿过P3，到达房间C
[幽灵████] (房间A) | [幽灵████] (房间B) | [玩家████] (房间C)
   ^房间A                ^房间B                 ^房间C

同时显示3个位置的部分，创造连续穿越的视觉效果！
```

这个可视化展示了多段裁切系统如何创建无缝的传送门穿越体验，让玩家能够同时看到自己在多个位置的部分，形成流畅的视觉连续性。
