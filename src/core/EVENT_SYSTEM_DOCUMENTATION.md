# Portal Demo ç»Ÿä¸€äº‹ä»¶ç®¡ç†ç³»ç»Ÿæ–‡æ¡£

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº† Portal Demo é¡¹ç›®ä¸­ç»Ÿä¸€äº‹ä»¶ç®¡ç†å™¨ï¼ˆEventManagerï¼‰çš„è®¾è®¡ã€å®ç°å’Œä½¿ç”¨æ–¹æ³•ã€‚

## ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [è®¾è®¡ç†å¿µ](#è®¾è®¡ç†å¿µ)
3. [æ ¸å¿ƒæ¶æ„](#æ ¸å¿ƒæ¶æ„)
4. [äº‹ä»¶å¤„ç†ç­–ç•¥](#äº‹ä»¶å¤„ç†ç­–ç•¥)
5. [åŸºç¡€åŠŸèƒ½](#åŸºç¡€åŠŸèƒ½)
6. [é«˜çº§åŠŸèƒ½](#é«˜çº§åŠŸèƒ½)
7. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
8. [é…ç½®ç®¡ç†](#é…ç½®ç®¡ç†)
9. [ç›‘æ§ä¸è°ƒè¯•](#ç›‘æ§ä¸è°ƒè¯•)
10. [ç³»ç»Ÿé›†æˆ](#ç³»ç»Ÿé›†æˆ)
11. [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
12. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
13. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)

## ç³»ç»Ÿæ¦‚è¿°

EventManager æ˜¯ Portal Demo é¡¹ç›®çš„æ ¸å¿ƒäº‹ä»¶ç®¡ç†ç³»ç»Ÿï¼Œé‡‡ç”¨å¤–è§‚æ¨¡å¼ç»Ÿä¸€äº†å¤šç§äº‹ä»¶å¤„ç†æœºåˆ¶ï¼Œä¸ºæ¸¸æˆé€»è¾‘æä¾›å”¯ä¸€çš„äº‹ä»¶å‡ºå…¥å£ã€‚è¿™ä¸ªç³»ç»Ÿå±•ç°äº†ä»"ä½¿ç”¨è®¾è®¡æ¨¡å¼"åˆ°"é©¾é©­å’Œç®¡ç†è®¾è®¡æ¨¡å¼"çš„æ€ç»´è½¬å˜ã€‚

### è®¾è®¡ç›®æ ‡

- **ç»Ÿä¸€æ¥å£**ï¼šæä¾›ä¸€è‡´çš„äº‹ä»¶å¤„ç†APIï¼Œéšè—åº•å±‚å®ç°å¤æ‚æ€§
- **é«˜æ€§èƒ½**ï¼šé€šè¿‡å¯¹è±¡æ± ã€å¹¶å‘å¤„ç†ç­‰æŠ€æœ¯ä¼˜åŒ–æ€§èƒ½
- **çµæ´»æ€§**ï¼šæ”¯æŒå¤šç§äº‹ä»¶å¤„ç†ç­–ç•¥ï¼Œé€‚åº”ä¸åŒåœºæ™¯éœ€æ±‚
- **å¯ç›‘æ§**ï¼šæä¾›è¯¦ç»†çš„ç»Ÿè®¡ä¿¡æ¯å’Œæ€§èƒ½åˆ†æåŠŸèƒ½
- **å¯é…ç½®**ï¼šæ”¯æŒè¿è¡Œæ—¶é…ç½®è°ƒæ•´ï¼Œä¾¿äºè°ƒä¼˜å’Œæµ‹è¯•

### æ ¸å¿ƒç‰¹æ€§

- âœ… **å¤šç§äº‹ä»¶å¤„ç†æ¨¡å¼**ï¼šç«‹å³å¤„ç†ã€é˜Ÿåˆ—å¤„ç†ã€å»¶è¿Ÿå¤„ç†
- âœ… **å®ä½“äº‹ä»¶ç®¡ç†**ï¼šåŸºäº ECS çš„äº‹ä»¶å®ä½“ç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… **ä¸´æ—¶æ ‡è®°ç³»ç»Ÿ**ï¼šè‡ªåŠ¨æ¸…ç†çš„ä¸´æ—¶ç»„ä»¶æ ‡è®°
- âœ… **å¯¹è±¡æ± ä¼˜åŒ–**ï¼šå‡å°‘å†…å­˜åˆ†é…å¼€é”€ï¼Œæå‡æ€§èƒ½
- âœ… **å¹¶å‘å®‰å…¨**ï¼šå¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„äº‹ä»¶å¤„ç†æ”¯æŒ
- âœ… **é…ç½®ç®¡ç†**ï¼šè¿è¡Œæ—¶é…ç½®è°ƒæ•´å’ŒæŒä¹…åŒ–
- âœ… **æ€§èƒ½åˆ†æ**ï¼šå®æ—¶æ€§èƒ½ç›‘æ§å’Œç»Ÿè®¡
- âœ… **å†…å­˜ç®¡ç†**ï¼šæ™ºèƒ½åƒåœ¾æ”¶é›†å’Œå†…å­˜ä¼˜åŒ–

## è®¾è®¡ç†å¿µ

### æ ¸å¿ƒæ€æƒ³
- **ç»Ÿä¸€æ¥å£**: æä¾›å•ä¸€çš„äº‹ä»¶ç®¡ç†å…¥å£ï¼Œéšè—åº•å±‚å®ç°å¤æ‚æ€§
- **ç­–ç•¥é€‰æ‹©**: æ ¹æ®äº‹ä»¶ç‰¹æ€§è‡ªåŠ¨æˆ–æ‰‹åŠ¨é€‰æ‹©æœ€ä¼˜å¤„ç†æ–¹å¼
- **æ€§èƒ½ä¼˜åŒ–**: ä¸åŒåœºæ™¯ä½¿ç”¨ä¸åŒçš„ä¼˜åŒ–ç­–ç•¥
- **ç±»å‹å®‰å…¨**: ä½¿ç”¨æ¨¡æ¿å’Œç±»å‹æ£€æŸ¥ç¡®ä¿ç¼–è¯‘æ—¶å®‰å…¨

### æ¶æ„åŸåˆ™
1. **å¤–è§‚æ¨¡å¼ (Facade)**: `EventManager` ä½œä¸ºç»Ÿä¸€æ¥å£
2. **ç­–ç•¥æ¨¡å¼ (Strategy)**: å†…éƒ¨æ ¹æ®äº‹ä»¶ç±»å‹é€‰æ‹©å¤„ç†ç­–ç•¥
3. **è§‚å¯Ÿè€…æ¨¡å¼ (Observer)**: Dispatcher äº‹ä»¶çš„å‘å¸ƒ-è®¢é˜…æœºåˆ¶
4. **æ•°æ®é©±åŠ¨**: Entity/Component äº‹ä»¶çš„æ•°æ®é©±åŠ¨å¤„ç†

## æ ¸å¿ƒæ¶æ„

### ä¸»è¦ç»„ä»¶

```
EventManager (å¤–è§‚)
â”œâ”€â”€ entt::dispatcher (ä¼ ç»Ÿäº‹ä»¶åˆ†å‘)
â”œâ”€â”€ EventPoolManager (å¯¹è±¡æ± ç®¡ç†)
â”œâ”€â”€ ConcurrentEventDispatcher (å¹¶å‘å¤„ç†)
â”œâ”€â”€ å»¶è¿Ÿäº‹ä»¶é˜Ÿåˆ—
â”œâ”€â”€ ä¸´æ—¶æ ‡è®°ç®¡ç†å™¨
â”œâ”€â”€ é…ç½®ç®¡ç†å™¨
â”œâ”€â”€ æ€§èƒ½åˆ†æå™¨
â””â”€â”€ ç»Ÿè®¡ä¿¡æ¯æ”¶é›†å™¨
```

### äº‹ä»¶å¤„ç†æµç¨‹

```
äº‹ä»¶è¾“å…¥ â†’ è·¯ç”±å†³ç­– â†’ å¤„ç†ç­–ç•¥é€‰æ‹© â†’ æ‰§è¡Œå¤„ç† â†’ ç»Ÿè®¡æ›´æ–°
    â†“           â†“            â†“           â†“          â†“
  ç«‹å³äº‹ä»¶    é˜Ÿåˆ—äº‹ä»¶     å¹¶å‘äº‹ä»¶     å®ä½“äº‹ä»¶   ä¸´æ—¶æ ‡è®°
    â†“           â†“            â†“           â†“          â†“
dispatcher  enqueue    concurrent    registry   marker
  .trigger   .queue      .queue      .create    .track
```

## äº‹ä»¶å¤„ç†ç­–ç•¥

### 1. Dispatcher äº‹ä»¶ (å³æ—¶/é˜Ÿåˆ—)

**é€‚ç”¨åœºæ™¯**:
- éŸ³æ•ˆæ’­æ”¾ã€UIæ›´æ–°ç­‰éœ€è¦ç«‹å³å“åº”çš„äº‹ä»¶
- çŠ¶æ€åŒæ­¥ã€æ‰¹é‡æ›´æ–°ç­‰éœ€è¦æ’åºçš„äº‹ä»¶

**ä¼˜åŠ¿**:
- ä½å»¶è¿Ÿå“åº”
- é«˜æ•ˆçš„å‘å¸ƒ-è®¢é˜…æœºåˆ¶
- æ”¯æŒå¤šä¸ªç›‘å¬å™¨

**ä½¿ç”¨ç¤ºä¾‹**:
```cpp
// ç«‹å³å“åº”çš„ç¢°æ’äº‹ä»¶
auto collision_event = EventFactory::create_collision_event(entity_a, entity_b, point, normal, impulse);
event_manager.publish_immediate(collision_event, EventMetadata{EventPriority::HIGH});

// é˜Ÿåˆ—å¤„ç†çš„çŠ¶æ€åŒæ­¥
auto sync_event = PhysicsStateSyncEvent{entity, position, rotation, velocity};
event_manager.enqueue(sync_event);
```

### 2. å®ä½“äº‹ä»¶ (æ•°æ®é©±åŠ¨çŠ¶æ€)

**é€‚ç”¨åœºæ™¯**:
- æŒç»­æ•ˆæœ (ä¸­æ¯’ã€ç‡ƒçƒ§ç­‰)
- å¤æ‚çŠ¶æ€ç®¡ç†
- éœ€è¦æŸ¥è¯¢å’Œæ£€ç´¢çš„äº‹ä»¶

**ä¼˜åŠ¿**:
- æ•°æ®é©±åŠ¨ï¼Œæ˜“äºæŸ¥è¯¢
- è‡ªç„¶çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- ä¸ ECS æ¶æ„å®Œç¾èåˆ

**ä½¿ç”¨ç¤ºä¾‹**:
```cpp
// æ·»åŠ ä¸­æ¯’çŠ¶æ€
event_manager.add_component_event(target_entity, PoisonedEventComponent(5.0f, 2.0f));

// åˆ›å»ºå¤æ‚äº‹ä»¶å®ä½“
auto quest_event = QuestCompletedEventComponent(quest_id, "Dragon Slayer", player_entity);
auto event_entity = event_manager.create_entity_event(std::move(quest_event));
```

### 3. ä¸´æ—¶æ ‡è®°äº‹ä»¶ (è‡ªåŠ¨æ¸…ç†)

**é€‚ç”¨åœºæ™¯**:
- çŸ­æœŸçŠ¶æ€æ ‡è®°
- ä¸€æ¬¡æ€§è§¦å‘å™¨
- å¸§çº§åˆ«çš„æ•ˆæœ

**ä¼˜åŠ¿**:
- è‡ªåŠ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
- é›¶å†…å­˜æ³„æ¼
- é«˜æ€§èƒ½çš„ä¸´æ—¶çŠ¶æ€

**ä½¿ç”¨ç¤ºä¾‹**:
```cpp
// 3å¸§åè‡ªåŠ¨æ¸…ç†çš„å—å‡»æ ‡è®°
event_manager.add_temporary_marker(target_entity, 
    HitMarkerComponent(direction, force), 3);

// 2ç§’åè‡ªåŠ¨æ¸…ç†çš„æ— æ•Œæ ‡è®°
event_manager.add_temporary_marker(player_entity, 
    InvulnerableMarkerComponent(2.0f), 120); // 60FPS * 2ç§’
```

### 4. å¹¶å‘äº‹ä»¶å¤„ç†

**é€‚ç”¨åœºæ™¯**:
- å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„äº‹ä»¶ç”Ÿäº§
- é«˜é¢‘äº‹ä»¶çš„ç¼“å†²å¤„ç†
- è·¨çº¿ç¨‹çš„å®‰å…¨äº‹ä»¶ä¼ é€’

**ä¼˜åŠ¿**:
- çº¿ç¨‹å®‰å…¨çš„äº‹ä»¶å…¥é˜Ÿ
- æ— é˜»å¡çš„äº‹ä»¶å¤„ç†
- é«˜å¹¶å‘æ€§èƒ½

**ä½¿ç”¨ç¤ºä¾‹**:
```cpp
// å¯ç”¨å¹¶å‘æ¨¡å¼
event_manager.set_concurrent_mode(true);

// ä»å·¥ä½œçº¿ç¨‹å®‰å…¨å‘é€äº‹ä»¶
std::thread worker([&]() {
    auto damage_event = EventFactory::create_damage_event(
        attacker, target, damage, position, "worker_damage"
    );
    event_manager.enqueue_concurrent(damage_event);
});
```

## åŸºç¡€åŠŸèƒ½

### 1. ç«‹å³äº‹ä»¶å¤„ç†

```cpp
// å®šä¹‰äº‹ä»¶å¤„ç†å™¨
event_manager.subscribe<CollisionStartEvent>().connect([](const CollisionStartEvent& event) {
    // ç«‹å³å“åº”ç¢°æ’äº‹ä»¶ï¼Œå¦‚æ’­æ”¾éŸ³æ•ˆ
    AudioManager::play_sound("collision.wav");
});

// å‘å¸ƒç«‹å³äº‹ä»¶
auto collision_event = EventFactory::create_collision_event(
    entity_a, entity_b, contact_point, normal, impulse
);
event_manager.publish_immediate(collision_event);
```

### 2. é˜Ÿåˆ—äº‹ä»¶å¤„ç†

```cpp
// åˆ›å»ºéœ€è¦å»¶è¿Ÿå¤„ç†çš„äº‹ä»¶
auto damage_event = EventFactory::create_damage_event(
    attacker, target, damage_amount, hit_position, damage_type
);

// æ·»åŠ åˆ°å¤„ç†é˜Ÿåˆ—
event_manager.enqueue(damage_event);

// åœ¨æ¸¸æˆå¾ªç¯ä¸­å¤„ç†é˜Ÿåˆ—äº‹ä»¶
event_manager.process_queued_events(delta_time);
```

### 3. å®ä½“äº‹ä»¶ç®¡ç†

```cpp
// åˆ›å»ºäº‹ä»¶å®ä½“ï¼ˆè‡ªåŠ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼‰
auto poison_entity = event_manager.create_entity_event(
    PoisonedEventComponent(duration, damage_per_second),
    EventMetadata{
        .category = "status_effect",
        .auto_cleanup = true,
        .frame_lifetime = 300  // 5ç§’@60fps
    }
);

// ç›´æ¥ä¸ºå®ä½“æ·»åŠ äº‹ä»¶ç»„ä»¶
event_manager.add_component_event(target_entity, 
    PoisonedEventComponent(5.0f, 2.0f));
```

### 4. ä¸´æ—¶æ ‡è®°ç³»ç»Ÿ

```cpp
// æ·»åŠ ä¸´æ—¶è§†è§‰æ•ˆæœæ ‡è®°
event_manager.add_temporary_marker(entity, 
    FlashEffectMarkerComponent(color, intensity), 
    duration_frames);

// æ ‡è®°ä¼šåœ¨æŒ‡å®šå¸§æ•°åè‡ªåŠ¨æ¸…ç†
```

## é«˜çº§åŠŸèƒ½

### 1. å¯¹è±¡æ± ä¼˜åŒ–

```cpp
// å¯ç”¨å¯¹è±¡æ± ï¼ˆé»˜è®¤å¯ç”¨ï¼‰
event_manager.set_object_pooling_enabled(true);

// é¢„çƒ­å¸¸ç”¨å¯¹è±¡æ± 
event_manager.warmup_object_pools();

// è·å–æ± ç»Ÿè®¡ä¿¡æ¯
auto pool_stats = event_manager.get_pool_statistics();
std::cout << "Pool reuse ratio: " << pool_stats.average_reuse_ratio * 100 << "%" << std::endl;

// æ‰‹åŠ¨æ¸…ç†è¿‡æœŸæ± 
event_manager.cleanup_expired_pools();
```

### 2. å¹¶å‘äº‹ä»¶å¤„ç†

```cpp
// å¯ç”¨å¹¶å‘æ¨¡å¼
event_manager.set_concurrent_mode(true);

// è®¾ç½®å·¥ä½œçº¿ç¨‹æ•°
event_manager.set_worker_thread_count(4);

// ä»å…¶ä»–çº¿ç¨‹å®‰å…¨åœ°å‘é€äº‹ä»¶
std::thread worker_thread([&]() {
    auto damage_event = EventFactory::create_damage_event(
        attacker, target, damage, position, "worker_damage"
    );
    
    // çº¿ç¨‹å®‰å…¨çš„äº‹ä»¶å…¥é˜Ÿ
    if (event_manager.enqueue_concurrent(damage_event)) {
        std::cout << "Event queued successfully" << std::endl;
    } else {
        std::cout << "Queue full, event dropped" << std::endl;
    }
});

// åœ¨ä¸»çº¿ç¨‹å¤„ç†å¹¶å‘äº‹ä»¶
event_manager.process_queued_events(delta_time);
```

### 3. å»¶è¿Ÿäº‹ä»¶å¤„ç†

```cpp
// å®‰æ’å»¶è¿Ÿæ‰§è¡Œçš„äº‹ä»¶
event_manager.schedule_event(
    damage_event,
    2.5f,  // 2.5ç§’åæ‰§è¡Œ
    EventHandlingStrategy::QUEUED
);

// å»¶è¿Ÿäº‹ä»¶ä¼šåœ¨ process_queued_events ä¸­è‡ªåŠ¨å¤„ç†
```

## æ€§èƒ½ä¼˜åŒ–

### å¯¹è±¡æ± é…ç½®

```cpp
// é…ç½®å¯¹è±¡æ± å‚æ•°
EventManager::Configuration config;
config.pool_initial_size = 200;     // åˆå§‹æ± å¤§å°
config.pool_max_size = 2000;        // æœ€å¤§æ± å¤§å°
config.pool_cleanup_interval = 60.0f; // æ¸…ç†é—´éš”(ç§’)

event_manager.apply_configuration(config);
```

### å¹¶å‘ä¼˜åŒ–

```cpp
// ä¼˜åŒ–å¹¶å‘é…ç½®
config.concurrent_queue_size = 20000;  // å¢å¤§å¹¶å‘é˜Ÿåˆ—
config.max_events_per_frame = 2000;    // æ¯å¸§æœ€å¤§äº‹ä»¶æ•°

// ç›‘æ§å¹¶å‘æ€§èƒ½
auto concurrency_stats = event_manager.get_concurrency_statistics();
if (concurrency_stats.concurrent_events_dropped > 0) {
    std::cout << "Warning: " << concurrency_stats.concurrent_events_dropped 
              << " events were dropped due to queue overflow" << std::endl;
}
```

## é…ç½®ç®¡ç†

### é…ç½®ç»“æ„

```cpp
struct Configuration {
    bool object_pooling_enabled = true;
    bool concurrent_mode_enabled = false;
    bool debug_mode_enabled = false;
    size_t concurrent_queue_size = 10000;
    size_t pool_initial_size = 100;
    size_t pool_max_size = 1000;
    float pool_cleanup_interval = 30.0f;
    int max_events_per_frame = 1000;
    int max_temporary_marker_frames = 300;
    bool performance_profiling_enabled = false;
};
```

### é…ç½®åº”ç”¨

```cpp
// åˆ›å»ºå’Œåº”ç”¨é…ç½®
EventManager::Configuration config;
config.debug_mode_enabled = true;
config.performance_profiling_enabled = true;
config.concurrent_mode_enabled = true;

event_manager.apply_configuration(config);

// è·å–å½“å‰é…ç½®
auto current_config = event_manager.get_configuration();
```

## ç›‘æ§ä¸è°ƒè¯•

### ç»Ÿè®¡ä¿¡æ¯æ”¶é›†

```cpp
// è·å–åŸºç¡€ç»Ÿè®¡
auto stats = event_manager.get_statistics();
std::cout << "Immediate events: " << stats.immediate_events_count << std::endl;
std::cout << "Queued events: " << stats.queued_events_count << std::endl;
std::cout << "Processing time: " << stats.last_process_time_ms << "ms" << std::endl;

// æŒ‰ç±»åˆ«æŸ¥çœ‹äº‹ä»¶ç»Ÿè®¡
for (const auto& [category, count] : stats.events_by_category) {
    std::cout << "Category [" << category << "]: " << count << " events" << std::endl;
}
```

### æ€§èƒ½åˆ†æ

```cpp
// å¯åŠ¨æ€§èƒ½åˆ†æ
event_manager.start_performance_profiling();

// æ‰§è¡Œæ¸¸æˆé€»è¾‘...

// è·å–æ€§èƒ½æŠ¥å‘Š
auto profile = event_manager.get_performance_profile();
std::cout << "Avg immediate event time: " << profile.avg_immediate_event_time_ms << "ms" << std::endl;
std::cout << "Peak memory usage: " << profile.peak_memory_usage_bytes << " bytes" << std::endl;

// åœæ­¢æ€§èƒ½åˆ†æ
event_manager.stop_performance_profiling();
```

### è°ƒè¯•è¾“å‡º

```cpp
// å¯ç”¨è°ƒè¯•æ¨¡å¼
event_manager.set_debug_mode(true);

// å¯¼å‡ºè¯¦ç»†ç»Ÿè®¡åˆ°æ§åˆ¶å°
event_manager.export_statistics_to_console();

// å¯¼å‡ºå¯¹è±¡æ± è¯Šæ–­ä¿¡æ¯
event_manager.export_pool_diagnostics();

// é‡ç½®ç»Ÿè®¡æ•°æ®
event_manager.reset_statistics();
```

### å†…å­˜ç›‘æ§

```cpp
// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
size_t current_memory = event_manager.get_total_memory_usage();
std::cout << "Current memory usage: " << current_memory << " bytes" << std::endl;

// å¼ºåˆ¶åƒåœ¾æ”¶é›†
event_manager.force_garbage_collection();

// è·å–åˆ†ç±»å†…å­˜ä½¿ç”¨ï¼ˆéœ€è¦å¯ç”¨è°ƒè¯•æ¨¡å¼ï¼‰
auto profile = event_manager.get_performance_profile();
std::cout << "Peak memory: " << profile.peak_memory_usage_bytes << " bytes" << std::endl;
```

## ç³»ç»Ÿé›†æˆ

### åœ¨ç°æœ‰ç³»ç»Ÿä¸­çš„ä½¿ç”¨

#### ç‰©ç†ç³»ç»Ÿé›†æˆ
```cpp
class EnhancedPhysicsSystem : public ISystem {
    EventManager& event_manager_;
    
    virtual bool initialize() override {
        // è®¢é˜…éœ€è¦ç‰©ç†å“åº”çš„äº‹ä»¶
        auto damage_sink = event_manager_.subscribe<DamageEvent>();
        damage_sink.connect([this](const DamageEvent& event) {
            apply_impact_force(event.target, event.hit_position, event.damage_amount);
        });
        
        auto collision_sink = event_manager_.subscribe<CollisionStartEvent>();
        collision_sink.connect([this](const CollisionStartEvent& event) {
            handle_collision_physics(event);
        });
        
        return true;
    }
    
    virtual void update(float delta_time) override {
        // ç‰©ç†æ¨¡æ‹Ÿ
        physics_world_->step(delta_time);
        
        // æ£€æµ‹å¹¶å‘å¸ƒç¢°æ’äº‹ä»¶
        auto collisions = detect_collisions();
        for (const auto& collision : collisions) {
            auto collision_event = EventFactory::create_collision_event(
                collision.entity_a, collision.entity_b,
                collision.contact_point, collision.normal, collision.impulse
            );
            event_manager_.publish_immediate(collision_event);
        }
        
        // å¤„ç†ä¸­æ¯’ç­‰æŒç»­æ•ˆæœ
        auto poisoned_view = event_manager_.get_registry().view<PoisonedEventComponent>();
        for (auto entity : poisoned_view) {
            auto& poison = poisoned_view.get<PoisonedEventComponent>(entity);
            poison.duration -= delta_time;
            
            if (poison.duration <= 0.0f) {
                event_manager_.get_registry().remove<PoisonedEventComponent>(entity);
            } else {
                // åˆ›å»ºæŒç»­ä¼¤å®³äº‹ä»¶
                auto damage_event = EventFactory::create_damage_event(
                    entt::null, entity, poison.damage_per_second * delta_time,
                    Vector3::Zero(), "poison"
                );
                event_manager_.enqueue(damage_event);
            }
        }
    }
};
```

#### PortalGameWorld ä¸­çš„é›†æˆ
```cpp
class PortalGameWorld {
private:
    entt::registry registry_;
    EventManager event_manager_;
    
public:
    PortalGameWorld() : event_manager_(registry_) {
        setup_event_handlers();
    }
    
    void setup_event_handlers() {
        // è®¾ç½®ä¼ é€é—¨ç©¿è¶Šäº‹ä»¶å¤„ç†
        auto portal_sink = event_manager_.subscribe<PortalTraversalEvent>();
        portal_sink.connect([this](const PortalTraversalEvent& event) {
            teleport_entity(event.entity, event.exit_position, event.exit_velocity);
        });
        
        // è®¾ç½®ä¼¤å®³äº‹ä»¶å¤„ç†
        auto damage_sink = event_manager_.subscribe<DamageEvent>();
        damage_sink.connect([this](const DamageEvent& event) {
            apply_damage(event.target, event.damage_amount);
            
            // æ·»åŠ å—ä¼¤é—ªçƒæ•ˆæœ
            event_manager_.add_temporary_marker(event.target,
                FlashEffectMarkerComponent(Vector3(1,0,0), 0.8f), 30);
        });
    }
    
    void update_systems(float delta_time) {
        // æ›´æ–°æ‰€æœ‰ç³»ç»Ÿ
        physics_system_->update(delta_time);
        
        // å¤„ç†äº‹ä»¶é˜Ÿåˆ—
        event_manager_.process_queued_events(delta_time);
        
        // å…¶ä»–ç³»ç»Ÿæ›´æ–°...
    }
    
    EventManager& get_event_manager() { return event_manager_; }
};
```

## ä½¿ç”¨ç¤ºä¾‹

### åŸºæœ¬æ¸¸æˆäº‹ä»¶å¤„ç†

```cpp
void setup_game_events(EventManager& event_manager) {
    // è®¾ç½®ç¢°æ’äº‹ä»¶å¤„ç†
    event_manager.subscribe<CollisionStartEvent>().connect([&](const CollisionStartEvent& event) {
        // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
        AudioManager::play_collision_sound(event.impact_force);
        
        // åˆ›å»ºç²’å­æ•ˆæœ
        ParticleSystem::create_impact_effect(event.contact_point, event.contact_normal);
    });
    
    // è®¾ç½®ä¼¤å®³äº‹ä»¶å¤„ç†
    event_manager.subscribe<DamageEvent>().connect([&](const DamageEvent& event) {
        // åº”ç”¨ä¼¤å®³
        HealthSystem::apply_damage(event.target, event.damage_amount);
        
        // åˆ›å»ºä¼¤å®³æ•°å­—æ˜¾ç¤º
        UISystem::show_damage_number(event.hit_position, event.damage_amount);
        
        // æ·»åŠ å—ä¼¤é—ªçƒæ•ˆæœ
        event_manager.add_temporary_marker(event.target,
            FlashEffectMarkerComponent(Vector3(1,0,0), 0.8f), 30);
    });
}

void game_loop(EventManager& event_manager, float delta_time) {
    // å¤„ç†ç‰©ç†ç¢°æ’
    auto collisions = PhysicsSystem::detect_collisions();
    for (const auto& collision : collisions) {
        auto collision_event = EventFactory::create_collision_event(
            collision.entity_a, collision.entity_b,
            collision.contact_point, collision.normal, collision.impulse
        );
        event_manager.publish_immediate(collision_event);
    }
    
    // å¤„ç†é˜Ÿåˆ—ä¸­çš„äº‹ä»¶
    event_manager.process_queued_events(delta_time);
}
```

## æœ€ä½³å®è·µ

### 1. äº‹ä»¶è®¾è®¡åŸåˆ™

- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªäº‹ä»¶ç±»å‹åº”è¯¥ä»£è¡¨ä¸€ä¸ªå…·ä½“çš„æ¸¸æˆæ¦‚å¿µ
- **ä¸å¯å˜æ€§**ï¼šäº‹ä»¶æ•°æ®åº”è¯¥æ˜¯åªè¯»çš„ï¼Œé¿å…å‰¯ä½œç”¨
- **è½»é‡çº§**ï¼šäº‹ä»¶ç»“æ„åº”è¯¥å°½é‡ç®€å•ï¼Œé¿å…åŒ…å«å¤æ‚å¯¹è±¡

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

- **æ‰¹é‡å¤„ç†**ï¼šå¯¹äºé«˜é¢‘äº‹ä»¶ï¼Œè€ƒè™‘æ‰¹é‡å¤„ç†è€Œéé€ä¸ªå¤„ç†
- **å¯¹è±¡æ± ä½¿ç”¨**ï¼šå¯ç”¨å¯¹è±¡æ± ä»¥å‡å°‘å†…å­˜åˆ†é…å¼€é”€
- **å¹¶å‘é…ç½®**ï¼šæ ¹æ®ç¡¬ä»¶é…ç½®è°ƒæ•´å·¥ä½œçº¿ç¨‹æ•°é‡
- **ç»Ÿè®¡ç›‘æ§**ï¼šå®šæœŸæ£€æŸ¥æ€§èƒ½ç»Ÿè®¡ï¼ŒåŠæ—¶å‘ç°ç“¶é¢ˆ

### 3. å†…å­˜ç®¡ç†

- **åŠæ—¶æ¸…ç†**ï¼šå®šæœŸè°ƒç”¨åƒåœ¾æ”¶é›†ä»¥é‡Šæ”¾æœªä½¿ç”¨çš„å†…å­˜
- **æ± å¤§å°è°ƒæ•´**ï¼šæ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µè°ƒæ•´å¯¹è±¡æ± å¤§å°
- **ç›‘æ§æ³„æ¼**ï¼šä½¿ç”¨æ€§èƒ½åˆ†æå™¨ç›‘æ§å†…å­˜ä½¿ç”¨è¶‹åŠ¿

### 4. è°ƒè¯•æŠ€å·§

- **åˆ†ç±»ç»Ÿè®¡**ï¼šä½¿ç”¨äº‹ä»¶ç±»åˆ«æ¥è·Ÿè¸ªä¸åŒç±»å‹äº‹ä»¶çš„åˆ†å¸ƒ
- **æ€§èƒ½åˆ†æ**ï¼šåœ¨æ€§èƒ½æ•æ„Ÿåœºæ™¯å¯ç”¨æ€§èƒ½åˆ†æ
- **è°ƒè¯•è¾“å‡º**ï¼šåœ¨å¼€å‘é˜¶æ®µå¯ç”¨è°ƒè¯•æ¨¡å¼è·å–è¯¦ç»†ä¿¡æ¯

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. äº‹ä»¶ä¸¢å¤±

**ç—‡çŠ¶**ï¼šæŸäº›äº‹ä»¶æ²¡æœ‰è¢«å¤„ç†
**å¯èƒ½åŸå› **ï¼š
- å¹¶å‘é˜Ÿåˆ—å·²æ»¡
- äº‹ä»¶å¤„ç†å™¨æœªæ­£ç¡®æ³¨å†Œ
- äº‹ä»¶åœ¨é”™è¯¯çš„çº¿ç¨‹ä¸­å‘é€

**è§£å†³æ–¹æ¡ˆ**ï¼š
```cpp
// æ£€æŸ¥å¹¶å‘ç»Ÿè®¡
auto stats = event_manager.get_concurrency_statistics();
if (stats.concurrent_events_dropped > 0) {
    // å¢åŠ é˜Ÿåˆ—å¤§å°æˆ–ä¼˜åŒ–å¤„ç†é€Ÿåº¦
    config.concurrent_queue_size *= 2;
    event_manager.apply_configuration(config);
}

// éªŒè¯äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ
event_manager.set_debug_mode(true);  // æŸ¥çœ‹è°ƒè¯•è¾“å‡º
```

#### 2. æ€§èƒ½ä¸‹é™

**ç—‡çŠ¶**ï¼šäº‹ä»¶å¤„ç†è€—æ—¶å¢åŠ 
**å¯èƒ½åŸå› **ï¼š
- å¯¹è±¡æ± æœªå¯ç”¨æˆ–é…ç½®ä¸å½“
- äº‹ä»¶å¤„ç†å™¨é€»è¾‘è¿‡äºå¤æ‚
- å†…å­˜ç¢ç‰‡åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š
```cpp
// å¯ç”¨æ€§èƒ½åˆ†æ
event_manager.start_performance_profiling();

// æ£€æŸ¥å¯¹è±¡æ± æ•ˆç‡
auto pool_stats = event_manager.get_pool_statistics();
if (pool_stats.average_reuse_ratio < 0.5f) {
    // è°ƒæ•´æ± é…ç½®
    config.pool_initial_size *= 2;
    config.pool_max_size *= 2;
}

// å¼ºåˆ¶åƒåœ¾æ”¶é›†
event_manager.force_garbage_collection();
```

#### 3. å†…å­˜æ³„æ¼

**ç—‡çŠ¶**ï¼šå†…å­˜ä½¿ç”¨æŒç»­å¢é•¿
**å¯èƒ½åŸå› **ï¼š
- äº‹ä»¶å®ä½“æœªè¢«æ­£ç¡®æ¸…ç†
- å¯¹è±¡æ± æ— é™å¢é•¿
- ä¸´æ—¶æ ‡è®°æœªåˆ°æœŸ

**è§£å†³æ–¹æ¡ˆ**ï¼š
```cpp
// ç›‘æ§å†…å­˜ä½¿ç”¨
size_t current_memory = event_manager.get_total_memory_usage();
std::cout << "Memory usage: " << current_memory << " bytes" << std::endl;

// æ£€æŸ¥æ± ç»Ÿè®¡
event_manager.export_pool_diagnostics();

// å¼ºåˆ¶æ¸…ç†
event_manager.force_garbage_collection();
```

### è°ƒè¯•å·¥å…·

#### 1. äº‹ä»¶è¿½è¸ª

```cpp
// å¯ç”¨è¯¦ç»†è°ƒè¯•
event_manager.set_debug_mode(true);

// æ¯ä¸ªäº‹ä»¶éƒ½ä¼šè¾“å‡ºè°ƒè¯•ä¿¡æ¯ï¼š
// EventManager: publish_immediate - CollisionStartEvent (Frame: 1234)
```

#### 2. æ€§èƒ½åˆ†æ

```cpp
// è·å–è¯¦ç»†æ€§èƒ½æŠ¥å‘Š
auto profile = event_manager.get_performance_profile();
std::cout << "Performance Analysis:" << std::endl;
std::cout << "  Immediate events avg time: " << profile.avg_immediate_event_time_ms << "ms" << std::endl;
std::cout << "  Frame processing time: " << profile.frame_processing_time_ms << "ms" << std::endl;
std::cout << "  Profiling overhead: " << profile.profiling_overhead_ms << "ms" << std::endl;
```

#### 3. ç»Ÿè®¡æŠ¥å‘Š

```cpp
// å¯¼å‡ºå®Œæ•´ç»Ÿè®¡æŠ¥å‘Š
event_manager.export_statistics_to_console();

// è¾“å‡ºç¤ºä¾‹ï¼š
// === EventManager Statistics ===
// Events:
//   Immediate: 1523
//   Queued: 892
//   Entity Events: 45
//   Temporary Markers: 12
//   Last Process Time: 0.23ms
// ...
```

## ç‰ˆæœ¬å†å²

### v2.0 (å½“å‰ç‰ˆæœ¬)
- âœ… æ·»åŠ å¯¹è±¡æ± ä¼˜åŒ–
- âœ… å®ç°å¹¶å‘äº‹ä»¶å¤„ç†
- âœ… å¢åŠ é…ç½®ç®¡ç†ç³»ç»Ÿ
- âœ… å®Œå–„æ€§èƒ½åˆ†æåŠŸèƒ½
- âœ… æ·»åŠ å†…å­˜ç®¡ç†å’Œåƒåœ¾æ”¶é›†
- âœ… æ‰©å±•ç›‘æ§å’Œè°ƒè¯•åŠŸèƒ½

### v1.0 (åˆå§‹ç‰ˆæœ¬)
- âœ… åŸºç¡€äº‹ä»¶åˆ†å‘æœºåˆ¶
- âœ… å®ä½“äº‹ä»¶ç®¡ç†
- âœ… ä¸´æ—¶æ ‡è®°ç³»ç»Ÿ
- âœ… å»¶è¿Ÿäº‹ä»¶å¤„ç†

## åç»­è®¡åˆ’

- ğŸ”„ äº‹ä»¶åºåˆ—åŒ–å’Œç½‘ç»œåŒæ­¥æ”¯æŒ
- ğŸ”„ å¯è§†åŒ–äº‹ä»¶æµè°ƒè¯•å·¥å…·
- ğŸ”„ è‡ªåŠ¨åŒ–æ€§èƒ½åŸºå‡†æµ‹è¯•
- ğŸ”„ äº‹ä»¶å½•åˆ¶å’Œå›æ”¾åŠŸèƒ½
- ğŸ”„ æ›´å¤šäº‹ä»¶ç±»å‹çš„é¢„å®šä¹‰æ”¯æŒ

---

**æ–‡æ¡£ç»´æŠ¤è€…**: Portal Demo å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2024å¹´  
**ç‰ˆæœ¬**: 2.0
