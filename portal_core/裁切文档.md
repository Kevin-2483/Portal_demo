1. ç¢°æ’æª¢æ¸¬çš„è²¬ä»»åˆ†å·¥
æ‚¨èªªå¾—å®Œå…¨æ­£ç¢º - ç¢°æ’æª¢æ¸¬ç¢ºå¯¦æ‡‰è©²æ˜¯ç‰©ç†å¼•æ“çš„å·¥ä½œï¼æˆ‘å€‘çš„æ¶æ§‹æ˜¯é€™æ¨£åˆ†å·¥çš„ï¼š

å·²å»ºç«‹ collision_responsibility.cpp
```
/**
 * ç¢°æ’æª¢æ¸¬è²¬ä»»åˆ†å·¥èªªæ˜
 */

// === ç‰©ç†å¼•æ“è² è²¬ (é€é IPhysicsQuery æ¥å£) ===
class EnginePhysicsQuery : public IPhysicsQuery {
public:
    // å¼•æ“è² è²¬æª¢æ¸¬å¯¦é«”æ˜¯å¦èˆ‡å‚³é€é–€å¹¾ä½•é«”ç¢°æ’
    bool is_entity_intersecting_portal(EntityId entity_id, PortalId portal_id) const override {
        // 1. å–å¾—å¯¦é«”çš„ç¢°æ’é«” (AABB, Mesh, Capsuleç­‰)
        // 2. å–å¾—å‚³é€é–€çš„å¹¾ä½•å½¢ç‹€ (çŸ©å½¢å¹³é¢)
        // 3. ä½¿ç”¨å¼•æ“çš„ç¢°æ’æª¢æ¸¬ç³»çµ±åˆ¤æ–·æ˜¯å¦ç›¸äº¤
        // 4. å›å‚³ true/false
    }
    
    // å¼•æ“è² è²¬å¯¦é«”è®Šæ›å’ŒåŒ…åœç›’æŸ¥è©¢
    Transform get_entity_transform(EntityId entity_id) const override;
    Vector3 get_entity_bounds_min(EntityId entity_id) const override;
    Vector3 get_entity_bounds_max(EntityId entity_id) const override;
};

// === Portalåº«è² è²¬ (ç´”æ•¸å­¸è¨ˆç®—) ===
class PortalManager {
public:
    void update(float delta_time) {
        // åº«ä¸åšç¢°æ’æª¢æ¸¬ï¼Œåªæ˜¯è©¢å•å¼•æ“çµæœ
        for (auto& [entity_id, entity_state] : registered_entities_) {
            for (auto& [portal_id, portal] : portals_) {
                // è©¢å•å¼•æ“ï¼šé€™å€‹å¯¦é«”æ˜¯å¦èˆ‡å‚³é€é–€ç¢°æ’ï¼Ÿ
                bool is_intersecting = interfaces_.physics_query->is_entity_intersecting_portal(
                    entity_id, portal_id
                );
                
                if (is_intersecting) {
                    // åº«åªè² è²¬æ•¸å­¸è¨ˆç®—ï¼šå¯¦é«”æ‡‰è©²è¢«å‚³é€åˆ°å“ªè£¡ï¼Ÿ
                    calculate_teleport_destination(entity_id, portal_id);
                }
            }
        }
    }
};
```

2. æ¨¡å‹è£åˆ‡çš„å…·é«”å¯¦ç¾
æ¨¡å‹è£åˆ‡æ˜¯åœ¨GPUæ¸²æŸ“ç®¡ç·šä¸­å¯¦ç¾çš„ï¼Œä¸æ˜¯åœ¨CPUç‰©ç†å±¤é¢ï¼š

å·²å»ºç«‹ model_clipping_implementation.cpp
```
/**
 * æ¨¡å‹è£åˆ‡å¯¦ç¾è©³è§£
 * 
 * æ¨¡å‹è£åˆ‡ç™¼ç”Ÿåœ¨GPUæ¸²æŸ“éšæ®µï¼Œä¸æ˜¯ç‰©ç†éšæ®µ
 */

// === æ­¥é©Ÿ1ï¼šPortalåº«è¨ˆç®—è£åˆ‡å¹³é¢ ===
ClippingPlane PortalManager::get_entity_clipping_plane(EntityId entity_id) {
    // æ‰¾åˆ°å¯¦é«”æ­£åœ¨ç©¿è¶Šçš„å‚³é€é–€
    const Portal* portal = find_portal_being_traversed(entity_id);
    
    // è¨ˆç®—å‚³é€é–€å¹³é¢ä½œç‚ºè£åˆ‡å¹³é¢
    return ClippingPlane::from_point_and_normal(
        portal->get_center(),      // å‚³é€é–€ä¸­å¿ƒé»
        portal->get_normal()       // å‚³é€é–€æ³•å‘é‡
    );
}

// === æ­¥é©Ÿ2ï¼šå¼•æ“åœ¨æ¸²æŸ“æ™‚æ‡‰ç”¨è£åˆ‡ ===
class GameEngine {
public:
    void render_entity(EntityId entity_id) {
        // æª¢æŸ¥å¯¦é«”æ˜¯å¦éœ€è¦è£åˆ‡
        ClippingPlane clip_plane;
        bool needs_clipping = portal_manager.get_entity_clipping_plane(entity_id, clip_plane);
        
        if (needs_clipping) {
            // === GPUç«¯å¯¦ç¾æ–¹å¼ ===
            
            // æ–¹æ³•1ï¼šä½¿ç”¨OpenGLè£åˆ‡å¹³é¢
            if (using_opengl) {
                glEnable(GL_CLIP_PLANE0);
                double plane_equation[4] = {
                    clip_plane.normal.x,
                    clip_plane.normal.y, 
                    clip_plane.normal.z,
                    -clip_plane.distance
                };
                glClipPlane(GL_CLIP_PLANE0, plane_equation);
            }
            
            // æ–¹æ³•2ï¼šåœ¨é ‚é»è‘—è‰²å™¨ä¸­è£åˆ‡
            if (using_modern_opengl) {
                shader.set_uniform("u_clip_plane", 
                    glm::vec4(clip_plane.normal.x, clip_plane.normal.y, 
                             clip_plane.normal.z, -clip_plane.distance));
                /* 
                 * åœ¨é ‚é»è‘—è‰²å™¨ä¸­ï¼š
                 * gl_ClipDistance[0] = dot(world_position, u_clip_plane);
                 * 
                 * GPUæœƒè‡ªå‹•ä¸Ÿæ£„ gl_ClipDistance[0] < 0 çš„ç‰‡æ®µ
                 */
            }
            
            // æ–¹æ³•3ï¼šåœ¨ç‰‡æ®µè‘—è‰²å™¨ä¸­ä¸Ÿæ£„åƒç´ 
            if (using_fragment_discard) {
                shader.set_uniform("u_clip_plane", clip_plane);
                /*
                 * åœ¨ç‰‡æ®µè‘—è‰²å™¨ä¸­ï¼š
                 * float distance = dot(world_position.xyz, u_clip_plane.xyz) + u_clip_plane.w;
                 * if (distance < 0.0) discard;
                 */
            }
        }
        
        // æ­£å¸¸æ¸²æŸ“å¯¦é«”
        render_mesh(entity_id);
        
        if (needs_clipping) {
            // æ¸…ç†è£åˆ‡ç‹€æ…‹
            if (using_opengl) {
                glDisable(GL_CLIP_PLANE0);
            }
        }
    }
};

// === GPUè‘—è‰²å™¨ç¯„ä¾‹ (GLSL) ===
/*
// é ‚é»è‘—è‰²å™¨
#version 330 core
layout (location = 0) in vec3 aPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec4 u_clip_plane;  // (normal.xyz, -distance)

void main() {
    vec4 world_pos = model * vec4(aPos, 1.0);
    gl_Position = projection * view * world_pos;
    
    // è¨ˆç®—åˆ°è£åˆ‡å¹³é¢çš„è·é›¢
    gl_ClipDistance[0] = dot(world_pos, u_clip_plane);
}

// ç‰‡æ®µè‘—è‰²å™¨
#version 330 core
out vec4 FragColor;

void main() {
    // GPUè‡ªå‹•è™•ç†è£åˆ‡ï¼Œè¢«è£åˆ‡çš„ç‰‡æ®µä¸æœƒé€²å…¥ç‰‡æ®µè‘—è‰²å™¨
    FragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
*/
```

3. å®Œæ•´çš„æ¸²æŸ“æµç¨‹
å·²å»ºç«‹ complete_portal_rendering.cpp

```
/**
 * å®Œæ•´çš„Portalæ¸²æŸ“æµç¨‹
 * å±•ç¤ºç‰©ç†æª¢æ¸¬å’Œæ¸²æŸ“è£åˆ‡çš„é…åˆ
 */

class CompletePortalRenderingExample {
public:
    void frame_update(float delta_time) {
        // === æ­¥é©Ÿ1ï¼šç‰©ç†æ›´æ–° (å¼•æ“è² è²¬) ===
        physics_engine.update(delta_time);
        
        // === æ­¥é©Ÿ2ï¼šPortalç³»çµ±æ›´æ–° (åº«è² è²¬æ•¸å­¸) ===
        portal_manager.update(delta_time);
        
        // === æ­¥é©Ÿ3ï¼šæ¸²æŸ“æº–å‚™ ===
        prepare_rendering();
    }
    
private:
    void prepare_rendering() {
        CameraParams main_camera = render_query.get_main_camera();
        
        // === A. è¨ˆç®—Portalæ¸²æŸ“é€šé“ ===
        auto render_passes = portal_manager.calculate_render_passes(main_camera, 3);
        
        // === B. æ¸²æŸ“æ¯å€‹é€šé“ ===
        for (const auto& pass : render_passes) {
            render_portal_pass(pass);
        }
        
        // === C. æ¸²æŸ“ä¸»å ´æ™¯ ===
        render_main_scene();
    }
    
    void render_portal_pass(const RenderPassDescriptor& pass) {
        // 1. é…ç½®æ¨¡æ¿ç·©è¡ (ç‚ºPortalé–‹æ´)
        render_manipulator.configure_stencil_buffer(true, pass.stencil_ref_value);
        
        // 2. è¨­ç½®è£åˆ‡å¹³é¢ (é˜²æ­¢çœ‹åˆ°PortalèƒŒå¾Œ)
        if (pass.should_clip) {
            render_manipulator.set_clipping_plane(pass.clipping_plane);
        }
        
        // 3. ä½¿ç”¨è™›æ“¬ç›¸æ©Ÿæ¸²æŸ“å ´æ™¯
        set_camera(pass.virtual_camera);
        render_all_entities();
        
        // 4. é‡ç½®ç‹€æ…‹
        render_manipulator.reset_render_state();
    }
    
    void render_main_scene() {
        // æ¸²æŸ“æ‰€æœ‰å¯¦é«”ï¼ŒåŒ…æ‹¬å¯èƒ½éœ€è¦è£åˆ‡çš„å¯¦é«”
        for (EntityId entity_id : scene_entities) {
            render_entity_with_portal_clipping(entity_id);
        }
    }
    
    void render_entity_with_portal_clipping(EntityId entity_id) {
        // === é—œéµï¼šæª¢æŸ¥å¯¦é«”æ˜¯å¦æ­£åœ¨ç©¿è¶ŠPortal ===
        ClippingPlane entity_clip;
        bool needs_clipping = portal_manager.get_entity_clipping_plane(entity_id, entity_clip);
        
        if (needs_clipping) {
            // å¯¦é«”æ­£åœ¨ç©¿è¶ŠPortalï¼éœ€è¦è£åˆ‡ï¼
            
            /*
             * è¦–è¦ºæ•ˆæœï¼š
             * 
             * æœªè£åˆ‡ï¼š     è£åˆ‡å¾Œï¼š
             *    â–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆâ–ˆâ–ˆ|
             *    â–ˆâ–ˆâ–ˆâ–ˆ   =>   â–ˆâ–ˆâ–ˆâ–ˆ|  Portalå¹³é¢
             *    â–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆâ–ˆâ–ˆ|
             * 
             * åªæœ‰Portalä¸€å´çš„éƒ¨åˆ†å¯è¦‹
             */
            
            render_manipulator.set_clipping_plane(entity_clip);
            render_mesh(entity_id);
            render_manipulator.disable_clipping_plane();
        } else {
            // æ­£å¸¸æ¸²æŸ“
            render_mesh(entity_id);
        }
    }
};

/**
 * å¯¦éš›çš„è¦–è¦ºæ•ˆæœï¼š
 * 
 * 1. ç©å®¶èµ°å‘Portalï¼š
 *    - ç‰©ç†å¼•æ“æª¢æ¸¬åˆ°ç¢°æ’
 *    - Portalåº«é–‹å§‹è¿½è¸ªç©¿è¶Šç‹€æ…‹
 *    - æ¸²æŸ“æ™‚ä¸è£åˆ‡ï¼ˆå®Œæ•´é¡¯ç¤ºï¼‰
 * 
 * 2. ç©å®¶éƒ¨åˆ†ç©¿è¶ŠPortalï¼š
 *    - ç‰©ç†å¼•æ“ç¹¼çºŒå›å ±ç¢°æ’
 *    - Portalåº«è¨ˆç®—ç©¿è¶Šé€²åº¦
 *    - æ¸²æŸ“æ™‚ç”¨Portalå¹³é¢è£åˆ‡ç©å®¶æ¨¡å‹
 *    - æ•ˆæœï¼šåªçœ‹åˆ°Portalä¸€å´çš„èº«é«”éƒ¨åˆ†
 * 
 * 3. ç©å®¶å®Œå…¨ç©¿è¶ŠPortalï¼š
 *    - Portalåº«å®Œæˆå‚³é€æ•¸å­¸è¨ˆç®—
 *    - å¼•æ“æ”¶åˆ°å‚³é€æŒ‡ä»¤ï¼Œç§»å‹•å¯¦é«”åˆ°æ–°ä½ç½®
 *    - æ¸²æŸ“æ¢å¾©æ­£å¸¸ï¼ˆä¸å†éœ€è¦è£åˆ‡ï¼‰
 */
```


ç¸½çµ
ç¢°æ’æª¢æ¸¬åˆ†å·¥ï¼š

âœ… ç‰©ç†å¼•æ“ (é€éIPhysicsQuery)ï¼šæª¢æ¸¬å¯¦é«”èˆ‡Portalå¹¾ä½•é«”çš„ç¢°æ’
âœ… Portalåº«ï¼šæ ¹æ“šç¢°æ’çµæœé€²è¡Œæ•¸å­¸è¨ˆç®—å’Œç‹€æ…‹ç®¡ç†
æ¨¡å‹è£åˆ‡å¯¦ç¾ï¼š

ğŸ¯ CPUéšæ®µï¼šPortalåº«è¨ˆç®—ç²¾ç¢ºçš„è£åˆ‡å¹³é¢
ğŸ¨ GPUéšæ®µï¼šå¼•æ“ä½¿ç”¨è£åˆ‡å¹³é¢åœ¨æ¸²æŸ“ç®¡ç·šä¸­å¯¦æ™‚è£åˆ‡å¹¾ä½•é«”
ğŸ“ æ•¸å­¸åŸç†ï¼šä½¿ç”¨å¹³é¢æ–¹ç¨‹å¼ ax + by + cz + d = 0 åœ¨GPUä¸­ä¸Ÿæ£„ç‰‡æ®µ
é€™å€‹è¨­è¨ˆå®Œç¾åˆ†é›¢äº†è²¬ä»»ï¼š

ç‰©ç†å¼•æ“å°ˆæ³¨ç¢°æ’æª¢æ¸¬
Portalåº«å°ˆæ³¨æ•¸å­¸è¨ˆç®—
GPUå°ˆæ³¨é«˜æ•ˆæ¸²æŸ“è£åˆ‡